{
  "comments": [
    {
      "key": {
        "uuid": "AAAA/H//+t4\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 77,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "this is not a type, but a structure, please rename to \"create_stat_work_struct\"",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+t0\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 234,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "do not typecast to void *, it is superfluous. This applies to everywhere else in the file.",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+t8\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 420,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "you should use container_of to get to your container struct.",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+uM\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 429,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-10T23:33:20Z",
      "side": 1,
      "message": "if i understand this correctly, in steady state, for every packet on any interface, you intend to do 2 list walks one of which is doing strcmp and the other looking for uids?!\n\nFor at least the uids, you should look into a moving it to an rb_tree.\n\nAlso, you have also now added a point of contention for every packet since they all have to take the iface_list_lock before being dispatched to update the right stat structure.",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+uE\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 429,
      "author": {
        "id": 1005412
      },
      "writtenOn": "2011-03-10T23:44:17Z",
      "side": 1,
      "message": "Yes, there are currently two list walks (although the interface list should never really exceed  members - cellular, WiFi, Ethernet/bluetooth). In this version, I chose to replicate the strategy of uid_stats which also does a list walk on uids (iface_stats will replace uid_stats in the near future). I could move from the list to rb_tree in pass 2 or this version if you sa so.\n\n\nAbout the iface_list_lock, it does add a point of contention for every packet, but I tried hard to move it to a point where its not done before the packet is dispatched, but after. I am updating stats just before kfree(sk_buff) is called for any outgoing/incoming packet - knowing that a kfree is done outside the critical path and as a low priority action.",
      "parentUuid": "AAAA/H//+uM\u003d",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+tw\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 490,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "instead of typecasting to work_struct, just pass \u0026create_work-\u003ecreate_work to be explicit.",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+ts\u003d",
        "filename": "drivers/misc/iface_stat.c",
        "patchSetId": 5
      },
      "lineNbr": 496,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "same as above, do not typecast here, but instead do \u0026create_work-\u003ecreate_work",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+to\u003d",
        "filename": "net/ipv4/ip_output.c",
        "patchSetId": 5
      },
      "lineNbr": 211,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:14:07Z",
      "side": 1,
      "message": "You should not do the test for protocol here, but rather do it inside your stat function. Also, you should just pass the whole skb into your stat update function and pull out all the relevant info there. So, your interface should probably just look like:\nint if_uid_update_tx(struct sk_buff *skb);\n\nThis will let you control how to dispatch inside your function based on the protocol, pull out exactly what you need from skb-\u003esk (uid), get the inferface info and packet len, etc. This will also mean that your change to ip_output.c is minimal and is easy to maintain.",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+tg\u003d",
        "filename": "net/ipv4/ip_output.c",
        "patchSetId": 5
      },
      "lineNbr": 211,
      "author": {
        "id": 1005412
      },
      "writtenOn": "2011-03-11T00:23:29Z",
      "side": 1,
      "message": "In that case the interface would have to be different for  if_uid_update_tx and  if_uid_update_rx, as I cannot pass struct sk_buff on the receive side, as on the receive path, skb_pull(ip_header) has already been invoked and I will never know the length of the incoming ip_header. \n\nFor the sake of consistency of interface on outgoing/incoming path, I chose to do the parsing here.",
      "parentUuid": "AAAA/H//+to\u003d",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/H//+tY\u003d",
        "filename": "net/ipv4/ip_output.c",
        "patchSetId": 5
      },
      "lineNbr": 211,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2011-03-11T00:26:15Z",
      "side": 1,
      "message": "so how about if_uid_stat_update_(t|r)x(skb, len)?",
      "parentUuid": "AAAA/H//+tg\u003d",
      "revId": "75e20df31768ab895c9d7fee9efa4c029fb806b0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}