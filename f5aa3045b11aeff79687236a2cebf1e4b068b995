{
  "comments": [
    {
      "key": {
        "uuid": "65810917_8781e699",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-24T19:08:39Z",
      "side": 0,
      "message": "client is available here as inode-\u003ei_private.  Why not add a kref to ion_client, lock dev-\u003elock here, check that client is in the rb_tree, if so use kref_get on it, and then kref_put in release?",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65bca932_2ff6a992",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1067053
      },
      "writtenOn": "2015-02-25T08:42:32Z",
      "side": 0,
      "message": "Hi Colin, \n\n  Even if I add \"struct kref refcount;\" to ion_client, there is no way to synchronize between seq_read and debugfs_remove_dir(). (ion_client_destroy()). ion_client data pointer is still with inode-\u003ei_private data, which allows seq_read to proceed further and access the memory which is already freed by the ion_client_destroy().\n\nAs per our trails, ion_client data struct is not consistent or valid after ion_client_destroy.",
      "parentUuid": "65810917_8781e699",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0233e3f5_aca26385",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-25T20:56:18Z",
      "side": 0,
      "message": "You can pass client and dev in a struct in inode-\u003ei_private, and then you can validate client against dev-\u003eclients before taking a reference to it.",
      "parentUuid": "65bca932_2ff6a992",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22ee27c7_ada97da5",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1067053
      },
      "writtenOn": "2015-02-26T04:44:05Z",
      "side": 0,
      "message": "Hi Colin, \n\n  Yes. I have already tried this option. if I keep client and dev in a new struct and that struct is passed in inode-\u003ei_private also leads to system crash. Because what ever the memory allocated for new struct need to be freed in ion_client_destroy(). \n\n\"if I form a structure with ion_device and client pair. But we need to allocate memory for this struct and we need free that memory as a part ion_client_destory(). This struct memory is need to be freed in the ion_client_destroy. So same problem will come with SLUB_DEBUG_ON flag(6b string).\"",
      "parentUuid": "0233e3f5_aca26385",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2f7af97_eb6b7100",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-26T05:33:07Z",
      "side": 0,
      "message": "Hm, you\u0027re right, allocating a new structure doesn\u0027t help.\n\nI believe the open function should be synchronized with debugfs_remove by debugfs.  If that\u0027s the case, then client is guaranteed to still exist until open exits.  You should be able to add a kref there to keep client alive until release is called.  You may also need to move debugfs_remove_recursive to the beginning of ion_client_destroy, and while you\u0027re at it destroy needs a call to mutex_destroy(\u0026client-\u003elock).",
      "parentUuid": "22ee27c7_ada97da5",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22ee27c7_b0af16f8",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1067053
      },
      "writtenOn": "2015-02-26T17:14:40Z",
      "side": 0,
      "message": "Hi Colin, \n 1) kref to ion_client is not working because ion_client data struct itself get freed and kref is part of ion_client.\n\n 2) Even if I move debugfs_remove_recursive to beginning of ion_client_destroy() device would crash, because on one core ion_debug_client_show() function might have just started before other core calls debugfs_remove_recursive().  \n\nFor that reason I am thinking that we should not hold ion_client in  inode-\u003ei_private and when ever control reaches ion_debug_client_show() take device lock and walk through RB tree nodes. when we are not holding ion_client there is no need to have different file for every ion_client. \n\n 3) We can call mutex_destory(\u0026client-\u003elock) to avoid crash at mutex_lock API in the ion_debug_client_show(), but device would crash when we are accessing another variables associated with ion_client data struct. Correct me If I am wrong ? \n\n-Thanks, Prasad",
      "parentUuid": "e2f7af97_eb6b7100",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}