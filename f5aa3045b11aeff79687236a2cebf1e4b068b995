{
  "comments": [
    {
      "key": {
        "uuid": "65810917_8781e699",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-24T19:08:39Z",
      "side": 0,
      "message": "client is available here as inode-\u003ei_private.  Why not add a kref to ion_client, lock dev-\u003elock here, check that client is in the rb_tree, if so use kref_get on it, and then kref_put in release?",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65bca932_2ff6a992",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1067053
      },
      "writtenOn": "2015-02-25T08:42:32Z",
      "side": 0,
      "message": "Hi Colin, \n\n  Even if I add \"struct kref refcount;\" to ion_client, there is no way to synchronize between seq_read and debugfs_remove_dir(). (ion_client_destroy()). ion_client data pointer is still with inode-\u003ei_private data, which allows seq_read to proceed further and access the memory which is already freed by the ion_client_destroy().\n\nAs per our trails, ion_client data struct is not consistent or valid after ion_client_destroy.",
      "parentUuid": "65810917_8781e699",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0233e3f5_aca26385",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-25T20:56:18Z",
      "side": 0,
      "message": "You can pass client and dev in a struct in inode-\u003ei_private, and then you can validate client against dev-\u003eclients before taking a reference to it.",
      "parentUuid": "65bca932_2ff6a992",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22ee27c7_ada97da5",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1067053
      },
      "writtenOn": "2015-02-26T04:44:05Z",
      "side": 0,
      "message": "Hi Colin, \n\n  Yes. I have already tried this option. if I keep client and dev in a new struct and that struct is passed in inode-\u003ei_private also leads to system crash. Because what ever the memory allocated for new struct need to be freed in ion_client_destroy(). \n\n\"if I form a structure with ion_device and client pair. But we need to allocate memory for this struct and we need free that memory as a part ion_client_destory(). This struct memory is need to be freed in the ion_client_destroy. So same problem will come with SLUB_DEBUG_ON flag(6b string).\"",
      "parentUuid": "0233e3f5_aca26385",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2f7af97_eb6b7100",
        "filename": "drivers/staging/android/ion/ion.c",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-02-26T05:33:07Z",
      "side": 0,
      "message": "Hm, you\u0027re right, allocating a new structure doesn\u0027t help.\n\nI believe the open function should be synchronized with debugfs_remove by debugfs.  If that\u0027s the case, then client is guaranteed to still exist until open exits.  You should be able to add a kref there to keep client alive until release is called.  You may also need to move debugfs_remove_recursive to the beginning of ion_client_destroy, and while you\u0027re at it destroy needs a call to mutex_destroy(\u0026client-\u003elock).",
      "parentUuid": "22ee27c7_ada97da5",
      "revId": "f5aa3045b11aeff79687236a2cebf1e4b068b995",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}