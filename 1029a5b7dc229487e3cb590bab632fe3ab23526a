{
  "comments": [
    {
      "key": {
        "uuid": "3bf75749_bd5e1f51",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T04:02:35Z",
      "side": 1,
      "message": "Here you change the lock_sock() to bh_lock_sock() in \ntcp_nuke_addr, so check sock_owned_by_user(sk) is needed.",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bfc0b2b_be5e1951",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T04:51:44Z",
      "side": 1,
      "message": "No, sock_owned_by_user guaranteed to be true until we call release_sock. bh_lock_sock does not affect the result of sock_owned_by_user(); all it does is:\n\n    #define bh_lock_sock(__sk)      spin_lock(\u0026((__sk)-\u003esk_lock.slock))\n\nYou can confirm this by adding:\n\n    BUG_ON(!sock_owned_by_user(sk));\n\nafter bh_lock_sock().",
      "parentUuid": "3bf75749_bd5e1f51",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f61b1659_06dadc41",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T05:14:27Z",
      "side": 1,
      "message": "Hello Lorenzo,\nIf we lack a judgement of sock_owned_by_user here, race condition\nwill still exist like this:\nCPU0                            CPU1\n   tcp_nuke_addr {                tcp_close {\n     --                             lock_sock\n     bh_lock_sock                   --\n     tcp_set_state {                tcp_set_state {\n       inet_put_port                    inet_put_port\n       --                               icsk_bind_hash-\u003enum_owners--\n       --                               icsk_bind_hash \u003d NULL\n       // access NULL pointer here  }\n       icsk_bind_hash-\u003enum_owners--",
      "parentUuid": "5bfc0b2b_be5e1951",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bfc0b2b_1e22ade4",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3559,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T03:04:02Z",
      "side": 1,
      "message": "I think here miss a judgement of sock_owned_by_user, or it will\nstill race with inet_put_port() in tcp_close(). So code should be\nlike this:\nif (!sock_owned_by_user(sk))\n    tcp_done(sk);",
      "range": {
        "startLine": 3559,
        "startChar": 4,
        "endLine": 3559,
        "endChar": 12
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16218a86_84a4067b",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3559,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T03:26:19Z",
      "side": 1,
      "message": "That doesn\u0027t make sense. Here sock_owned_by_user(sk) is guaranteed to be true, because we have called lock_sock.\n\nlock_sock basically does the following:\n  - Wait until sock_owned_by_user(sk) is false\n  - Lock the socket\n  - Set sock_owned_by_user to 1\n  - Unlock the socket\n\nI don\u0027t think the race you describe can happen. tcp_close calls inet_put port via tcp_set_state, which is only called with the userspace socket lock held. So there are two cases:\n\nCase #1: tcp_nuke_addr calls lock_sock first. In this case tcp_done() will do \"tcp_set_state(sk, TCP_CLOSE)\". Then when tcp_nuke_addr calls release_sock, tcp_close will run. But now sk-\u003esk_state \u003d\u003d TCP_CLOSE, so tcp_close will do \"goto adjudge_to_death\" and not call inet_put_port.\n\nCase #2: tcp_close calls lock_sock first. In this case tcp_close will call sock_orphan, which sets SOCK_DEAD. Then it calls sock_release. Now tcp_nuke_addr can run. But because SOCK_DEAD is true, tcp_nuke addr will just skip the socket without doing anything.",
      "parentUuid": "5bfc0b2b_1e22ade4",
      "range": {
        "startLine": 3559,
        "startChar": 4,
        "endLine": 3559,
        "endChar": 12
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}