{
  "comments": [
    {
      "key": {
        "uuid": "3bf75749_bd5e1f51",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T04:02:35Z",
      "side": 1,
      "message": "Here you change the lock_sock() to bh_lock_sock() in \ntcp_nuke_addr, so check sock_owned_by_user(sk) is needed.",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bfc0b2b_be5e1951",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T04:51:44Z",
      "side": 1,
      "message": "No, sock_owned_by_user guaranteed to be true until we call release_sock. bh_lock_sock does not affect the result of sock_owned_by_user(); all it does is:\n\n    #define bh_lock_sock(__sk)      spin_lock(\u0026((__sk)-\u003esk_lock.slock))\n\nYou can confirm this by adding:\n\n    BUG_ON(!sock_owned_by_user(sk));\n\nafter bh_lock_sock().",
      "parentUuid": "3bf75749_bd5e1f51",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f61b1659_06dadc41",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T05:14:27Z",
      "side": 1,
      "message": "Hello Lorenzo,\nIf we lack a judgement of sock_owned_by_user here, race condition\nwill still exist like this:\nCPU0                            CPU1\n   tcp_nuke_addr {                tcp_close {\n     --                             lock_sock\n     bh_lock_sock                   --\n     tcp_set_state {                tcp_set_state {\n       inet_put_port                    inet_put_port\n       --                               icsk_bind_hash-\u003enum_owners--\n       --                               icsk_bind_hash \u003d NULL\n       // access NULL pointer here  }\n       icsk_bind_hash-\u003enum_owners--",
      "parentUuid": "5bfc0b2b_be5e1951",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bfc0b2b_3ee0c9bb",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T05:30:49Z",
      "side": 1,
      "message": "No, that can\u0027t happen. The reason is the lock_sock statement in line 3551.\n\nIf tcp_close executes lock_sock first, then tcp_nuke_addr will block on the lock_sock in line 3551 until tcp_close calls release_sock. Once tcp_close calls release_sock, the SOCK_DEAD flag will be set, and tcp_nuke_addr will not call tcp_done.\n\nIf tcp_nuke_addr executes lock_sock first, then tcp_close will block on lock_sock until tcp_nuke_addr calls release_sock. By that time, sk-\u003esk_state is set to TCP_CLOSE, and lock_sock will not call tcp_set_state.",
      "parentUuid": "f61b1659_06dadc41",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1b06130b_bc3d01bc",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T05:32:53Z",
      "side": 1,
      "message": "... err, I mean \"By that time, sk-\u003esk_state is set to TCP_CLOSE, and *tcp_close* will not call tcp_set_state.\"",
      "parentUuid": "5bfc0b2b_3ee0c9bb",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1b06130b_9c3a45c0",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T05:56:08Z",
      "side": 1,
      "message": "Yes, you\u0027re right. I did not see the lock_sock in line 3551. \nThere\u0027s no race condition now.\n\nBut I think some boring warn message will be printed out\nfrom time to time by WARN_ON(sock_owned_by_user(sk))ï¼š\n\nCPU0                         CPU1\ntcp_nuke_addr()              tcp_close()\n--                           lock_sock\nlock_sock(wait)              release_sock\nlock_sock(ok)                --\nbh_lock_sock(ok)             bh_lock_sock(wait)\nbh_unlock_sock               bh_lock_sock(ok)\n--                           WARN_ON(sock_owned_by_user(sk))\nrelease_sock(wait)           bh_unlock_sock\nrelease_sock(ok)             --",
      "parentUuid": "1b06130b_bc3d01bc",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f61b1659_86d6cce6",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T06:35:58Z",
      "side": 1,
      "message": "Yes, we might occasionally hit that WARN_ON in tcp_close (and another one in inet_csk_listen_stop). But those messages are harmless, and should be very rare in actual use.",
      "parentUuid": "1b06130b_9c3a45c0",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dbe8fb67_a25b9e60",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3553,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T06:52:44Z",
      "side": 1,
      "message": "Yes, this happened in a very small probability.",
      "parentUuid": "f61b1659_86d6cce6",
      "range": {
        "startLine": 3553,
        "startChar": 3,
        "endLine": 3553,
        "endChar": 15
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9bf20354_60b0f21f",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3557,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-12T02:07:35Z",
      "side": 1,
      "message": "Hello Lorenzo,\nRefer to tcp_reset, I think smp_wmb() should be put after set sk-\u003esk_err, like this:\nsk-\u003esk_err \u003d ETIMEDOUT;\nsmp_wmb();\nsk-\u003esk_error_report(sk);",
      "range": {
        "startLine": 3556,
        "startChar": 4,
        "endLine": 3557,
        "endChar": 27
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bfc0b2b_1e22ade4",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3559,
      "author": {
        "id": 1086323
      },
      "writtenOn": "2015-11-11T03:04:02Z",
      "side": 1,
      "message": "I think here miss a judgement of sock_owned_by_user, or it will\nstill race with inet_put_port() in tcp_close(). So code should be\nlike this:\nif (!sock_owned_by_user(sk))\n    tcp_done(sk);",
      "range": {
        "startLine": 3559,
        "startChar": 4,
        "endLine": 3559,
        "endChar": 12
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16218a86_84a4067b",
        "filename": "net/ipv4/tcp.c",
        "patchSetId": 4
      },
      "lineNbr": 3559,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2015-11-11T03:26:19Z",
      "side": 1,
      "message": "That doesn\u0027t make sense. Here sock_owned_by_user(sk) is guaranteed to be true, because we have called lock_sock.\n\nlock_sock basically does the following:\n  - Wait until sock_owned_by_user(sk) is false\n  - Lock the socket\n  - Set sock_owned_by_user to 1\n  - Unlock the socket\n\nI don\u0027t think the race you describe can happen. tcp_close calls inet_put port via tcp_set_state, which is only called with the userspace socket lock held. So there are two cases:\n\nCase #1: tcp_nuke_addr calls lock_sock first. In this case tcp_done() will do \"tcp_set_state(sk, TCP_CLOSE)\". Then when tcp_nuke_addr calls release_sock, tcp_close will run. But now sk-\u003esk_state \u003d\u003d TCP_CLOSE, so tcp_close will do \"goto adjudge_to_death\" and not call inet_put_port.\n\nCase #2: tcp_close calls lock_sock first. In this case tcp_close will call sock_orphan, which sets SOCK_DEAD. Then it calls sock_release. Now tcp_nuke_addr can run. But because SOCK_DEAD is true, tcp_nuke addr will just skip the socket without doing anything.",
      "parentUuid": "5bfc0b2b_1e22ade4",
      "range": {
        "startLine": 3559,
        "startChar": 4,
        "endLine": 3559,
        "endChar": 12
      },
      "revId": "1029a5b7dc229487e3cb590bab632fe3ab23526a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}