{
  "comments": [
    {
      "key": {
        "uuid": "UuHDTiAA",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "When the policy max_freq is raised, and",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwWTYxHI",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "Ok.",
      "parentUuid": "UuHDTiAA",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UuBCTLFA",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1117,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "This mutex protects one-time init operations like notifier registration and sysfs attribute creation.  It doesn\u0027t need to be held for target load and speed adjustments (pcpu-\u003eenable_sem does need to be held).",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwWSB5Do",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1117,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "Hold this mutex to make sure the GOV_LIMITS is a sync operation, else there will have race when two or more threads update the max freq simultaneously.",
      "parentUuid": "UuBCTLFA",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UuFBwxE8",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1136,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "I don\u0027t think this is necessary.  It\u0027s OK for target_freq to be out of sync briefly so long as we fix things up at the next load-\u003efreq evaluation.  I\u0027d like to keep the number of additional places in the code that modify target_freq, apart from the load-\u003efreq calculation, to a minimum.",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwQTnODE",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1136,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "The target freq shall be updated too. E.g.\n1. target_freq \u003d max_freq(HI)\n2. max_freq changed from HI to LO, now if we don\u0027t update the target freq, then target_freq is equal to max_freq(HI) and cur_freq is equal to max_freq(LO). \n3. max_freq changed from LO to HI, but the timer is not rearmed in GOV_LIMITS because the cpu has a chance to hit IDLE and the timer is rearmed in idle callback. Now the cur_freq is max_freq(LO), policy-\u003emax is max_freq(HI) and target_freq is max_freq(HI).\n4. In timer callback, load is still HIGN(e.g. 99%) and the new_freq is policy-\u003emax(max_freq(HI). So the old target_freq is equal to new_freq and goto rearm_if_notmax. Now the target_freq is max so the timer is not rearmed, cur_freq stuck at max_freq(LO) until new_freq is not calculated as policy-\u003emax under a low load condition.",
      "parentUuid": "UuFBwxE8",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UuHBtyHQ",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1149,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "How about we just always do this (check for no timer active and start one if not) whenever the limits change?  That is, always do this without trying to keep extra state around to tell if the reason there\u0027s no timer active is because it was targeted at the previous max freq?  There might not be a timer active because the CPU is idle, but limits normally change infrequently.",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwUTRQE8",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1149,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "Yeah. Agree.  This is a good idea. I will try it.",
      "parentUuid": "UuHBtyHQ",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UuBBqTF4",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1150,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "Not needed.",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwSTOvK4",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1150,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "Yeah, this is redundant code.",
      "parentUuid": "UuBBqTF4",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UuHCs6Hk",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1151,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-05-16T20:44:17Z",
      "side": 1,
      "message": "Use cpufreq_interactive_timer_resched().  (The CPUFREQ_GOV_START code this was based on is a little special, it could probably use some cleanup as well, in some other patch.)  I think this should be enough:\n\nif (!timer_pending(\u0026pcpu-\u003ecpu_timer))\n    cpufreq_interactive_timer_resched(pcpu);",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UwYTbSG8",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 2
      },
      "lineNbr": 1151,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-05-17T03:59:21Z",
      "side": 1,
      "message": "The cpufreq_interactive_timer_resched can be called in timer callback and idle callback because it always pinned the timer on the same CPU. But we can not call it here because current thread maybe run at another CPU and pinned the timer at wrong CPU. So we have to call add_timer_on to pinned it on the target cpu.\n\nIf we don\u0027t care about whether it is pinned on the target cpu or not here, since it will pin the timer on the correct cpu in idle callback, then I\u0027m ok to call cpufreq_interactive_timer_resched.",
      "parentUuid": "UuHCs6Hk",
      "revId": "53d8a9a117b0fcda3c2c9d6d55e02c8550b0864f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}