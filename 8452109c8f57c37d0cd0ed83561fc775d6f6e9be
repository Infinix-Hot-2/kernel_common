{
  "comments": [
    {
      "key": {
        "uuid": "0ad591ff_4f261991",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-06-20T02:06:47Z",
      "side": 1,
      "message": "May still race with a cpu offlining in parallel?  Need get_online_cpus()?",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0aae7193_4ccfff08",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 1019659
      },
      "writtenOn": "2013-06-20T23:49:57Z",
      "side": 1,
      "message": "I agree with get/put_online_cpus() here. At least for 3.4.",
      "parentUuid": "0ad591ff_4f261991",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca753907_69fa016a",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-06-21T03:59:53Z",
      "side": 1,
      "message": "It is not good to call get/put_onine_cpus()  here because they hold mutex.\n\nIt shell not race with cpu down because this is a timer callback and preempt disabled.\n\nIt shell not race with cpu up because the timer shall be only re-armed after it is setting online.\n\nI\u0027d like to double check the online status here because the del_timer is called instead of del_timer_sync in idle callback.",
      "parentUuid": "0aae7193_4ccfff08",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ad591ff_6f2bdd57",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 1066,
      "author": {
        "id": 1004277
      },
      "writtenOn": "2013-06-20T02:06:47Z",
      "side": 1,
      "message": "Believe this isn\u0027t necessary, at least in 3.10, where cpufreq ensures all policy cpus are online prior to governor callbacks.  May be needed in 3.4, will check.",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca753907_49f54577",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 1066,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-06-21T03:59:53Z",
      "side": 1,
      "message": "I believe we need check the online status on 3.4 kernel. \n\nTake a 4 Cores for example. The 4 Cores will shall the same voltage/freq and so they are managed with the same policy. So the result is policy-\u003ecpu \u003d 0 and policy_cpus\u003d0/1/2/3\n\nWhen cpu0 is up, the cpufreq device driver will set all the cpus masks to the policy-\u003ecpus. The cpufreq governor driver will check this mask and start timer on all affected cpus. But actually the affected cpu maybe offline. It is offline because 1) maxcpus is set in command line or 2) run-time hotplug. It is not good to start the timer on the offline cpus, and it may cause kernel panic when start timer on a cpu that is never online yet because that cpu\u0027s idle is not initialized.\n\nWhen cpu1/2/3 is up/down, there is no governor start/stop is called because the policy is already set for them. So we have to stop/start the timer in idle callback.",
      "parentUuid": "0ad591ff_6f2bdd57",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a716808d_65968693",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 3
      },
      "lineNbr": 1066,
      "author": {
        "id": 1017041
      },
      "writtenOn": "2013-07-09T07:30:59Z",
      "side": 1,
      "message": "A upstream patch from kernel.org can make sure only online cpus will be managed by the policy. We can remove this check after that upstream patch merged.\n\ncommit 643ae6e81dd65b333a13259852405fc9f764ac76\nAuthor: Viresh Kumar \u003cviresh.kumar@linaro.org\u003e\nDate:   Sat Jan 12 05:14:38 2013 +0000\n\n    cpufreq: Manage only online cpus\n    \n    cpufreq core doesn\u0027t manage offline cpus and if driver-\u003einit() has returned\n    mask including offline cpus, it may result in unwanted behavior by cpufreq core\n    or governors.\n    \n    We need to get only online cpus in this mask. There are two places to fix this\n    mask, cpufreq core and cpufreq driver. It makes sense to do this at common place\n    and hence is done in core.\n    \n    Signed-off-by: Viresh Kumar \u003cviresh.kumar@linaro.org\u003e\n    Signed-off-by: Rafael J. Wysocki \u003crafael.j.wysocki@intel.com\u003e",
      "parentUuid": "ca753907_49f54577",
      "revId": "8452109c8f57c37d0cd0ed83561fc775d6f6e9be",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}