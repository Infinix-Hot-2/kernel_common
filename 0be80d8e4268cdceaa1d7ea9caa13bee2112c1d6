{
  "comments": [
    {
      "key": {
        "uuid": "6b2473a4_99e25f2d",
        "filename": "include/linux/lsm_audit.h",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Could make this a struct containing both the struct path (or dentry or whatever) and the unsigned int ioctlcmd and then display them both together on denials.  Also, this file diff belongs with the other change.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_dd6c3f75",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "I\u0027d put this file diff with the change that creates this header file. More generally, you only need at most two changes - one for the general LSM infrastructure and one for SELinux.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b49377c_8323fe11",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T21:44:59Z",
      "side": 1,
      "message": "Rgr. So two patches, a small (~20 lines) lsm_audit patch, and a much larger (~350 lines) selinux patch.",
      "parentUuid": "eb106340_dd6c3f75",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_39eb4b08",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3137,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use cred_sid() helper.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_9d76c73f",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3142,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use a struct so you can pass both the path and the cmd for inclusion in the audit message.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_faa0297a",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-01-15T02:10:54Z",
      "side": 1,
      "message": "a file descriptor could represent a plain file, character file, unix domain socket, etc... All of these can have ioctls performed on them.\n\nIt feels wrong to use SECLASS_FILE here, since it could also be a SECCLASS_CHR_FILE or SECCLASS_TCP_SOCKET depending on how it\u0027s called.\n\nStephen: are there any functions available which take a file descriptor, and return the SECCLASS appropriate to that file descriptor?",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2b051bfe_65f0fc21",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T03:10:52Z",
      "side": 1,
      "message": "Good catch! I believe that could be accessed by:\n\nstruct inode_security_struct *isec;\nstruct inode *inode \u003d file_inode(file);\nisec \u003d inode-\u003ei_security;\nisec-\u003esclass\n\nI will update tomorrow",
      "parentUuid": "eb106340_faa0297a",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_19f08fee",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "This is problematic; you are reusing an existing class/permission combination for a completely different purpose and different target context.  You really need a new permission for this check.  And it has to be added to COMMON_FILE_SOCK_PERMS in security/selinux/include/classmap.h so that it is defined for all file and socket classes.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ba19b5e_1ce5f562",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010099
      },
      "writtenOn": "2015-01-15T23:25:03Z",
      "side": 1,
      "message": "Actually, I think this check still won\u0027t be right even with its own permission.  IIUC, you want to be able to express in policy goals like \"untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device\".  Which requires that your check take into account the task/cred SID, the device node SID (i.e. the inode SID), and the ioctl command.  Normally we would think of the ioctl command as corresponding to a permission, but of course we can\u0027t support such a mapping due to the limited permission space and vast ioctl space.  By trying to map the ioctl command to a target SID, you are losing the device node SID from the equation.  Two independent checks, one on the device node SID and one on the ioctl command SID, doesn\u0027t seem sufficient, e.g. if you want to allow ioctl command N on device node D1 and ioctl command M on device node D2, you\u0027ll have to allow ioctl to D1 and D2 and ioctl (or new permission) to SID(N) and SID(M).  Which will also allow ioctl M on D1 and N on D2.  All that to say that I would not try to model this as a regular permission check.  Instead, just introduce a new structure within the policydb and a new function exported by the security server that allows checking based on source SID (the task/cred SID), target SID (the inode SID for the device file), maybe the target class (if we think we\u0027ll use the same target SID on both block and character devices and need to distinguish?), and the ioctl command.  Internally we\u0027d have something like the avtab to look up by source type, target type, and target class, and then check against your whitelist of ioctl commands.  More work, and more of a change to libsepol/checkpolicy, but seems more suited.",
      "parentUuid": "6b2473a4_19f08fee",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bcfdb48_cca10f36",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-01-16T00:20:20Z",
      "side": 1,
      "message": "\u003e IUC, you want to be able to express in policy goals like \"untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device\".\n\nThat\u0027s the ideal state, but I\u0027d also be OK with being able to express a policy like:\n\n  untrusted_apps can only invoke ioctls A, B-D, and Q on a character device\n\nwhich isn\u0027t as good as what you proposed above...\n\nIf we\u0027re trying to express the ideal state, what would that look like from a policy perspective? More concretely, I\u0027m having a tough time envisioning what an \"allow\" rule would look like under such a scenario.\n\nLike this?\n\n  allow untrusted_app gpu_device:chr_file ioctlA;\n  allow untrusted_app gpu_device:chr_file ioctlBD;",
      "parentUuid": "2ba19b5e_1ce5f562",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b971303_418cf418",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010099
      },
      "writtenOn": "2015-01-16T00:39:40Z",
      "side": 1,
      "message": "I\u0027d think you could specify a list of ioctl commands and/or ranges, ala allow untrusted_app gpu_device:chr_file { A B-D Q };\n\nDoing it as two checks might be ok if the ioctl command value space is largely non-overlapping among different drivers, or has the same semantic meaning across them for the values that are common, but I\u0027m not sure we can rely on that behavior.\n\nMight be helpful to work up an actual pseudo policy for a set of drivers in Android and assess.",
      "parentUuid": "2bcfdb48_cca10f36",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6bc55323_f4f13072",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-16T01:29:18Z",
      "side": 1,
      "message": "I\u0027m glad you brought this up.\n\nIt\u0027s important to note that this is the same issue with netport and netnode. They deal with socket TSID and port/addr TSID separately.\n\nI need to think about this more, but I will be considering two options:\n\n1) how to implement your example statement using the current two-check code and have the policy compiler solve the command space problem.\n\n2) how to use a single check. Adding a new statement to the policydb seems trivial, it\u0027s the avc lookup that is the difficulty. Currently it only uses the SSID, TSID and class for lookups. How would we expand this?",
      "parentUuid": "6b971303_418cf418",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b971303_e458aecb",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-16T14:59:52Z",
      "side": 1,
      "message": "The difference with netport/netnode is that ports and nodes are objects and thus it makes sense to label them and apply permission checks to them.  ioctl commands aren\u0027t objects per se but rather operations and thus map more logically to permissions.  I would think we could extend the AVC in much the same way as the avtab (or provide a separate cache), as they will continue to be keyed on SSID, TSID, and class but the struct av_decision returned by the security server could be extended to support returning an array of ioctl commands/operations and the AVC could simply check for a match.  If we can rely on the standard encoding of ioctl numbers (Documentation/ioctl/ioctl-decoding.txt and ioctl-number.txt), we could perhaps only consider the low half of the ioctl command value (driver + function) or even just the low byte (function) and thus represent the ioctl command array more compactly.",
      "parentUuid": "6bc55323_f4f13072",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}