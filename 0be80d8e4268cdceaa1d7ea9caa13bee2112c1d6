{
  "comments": [
    {
      "key": {
        "uuid": "6b2473a4_99e25f2d",
        "filename": "include/linux/lsm_audit.h",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Could make this a struct containing both the struct path (or dentry or whatever) and the unsigned int ioctlcmd and then display them both together on denials.  Also, this file diff belongs with the other change.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_dd6c3f75",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "I\u0027d put this file diff with the change that creates this header file. More generally, you only need at most two changes - one for the general LSM infrastructure and one for SELinux.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b49377c_8323fe11",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T21:44:59Z",
      "side": 1,
      "message": "Rgr. So two patches, a small (~20 lines) lsm_audit patch, and a much larger (~350 lines) selinux patch.",
      "parentUuid": "eb106340_dd6c3f75",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_39eb4b08",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3137,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use cred_sid() helper.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_9d76c73f",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3142,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use a struct so you can pass both the path and the cmd for inclusion in the audit message.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_faa0297a",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-01-15T02:10:54Z",
      "side": 1,
      "message": "a file descriptor could represent a plain file, character file, unix domain socket, etc... All of these can have ioctls performed on them.\n\nIt feels wrong to use SECLASS_FILE here, since it could also be a SECCLASS_CHR_FILE or SECCLASS_TCP_SOCKET depending on how it\u0027s called.\n\nStephen: are there any functions available which take a file descriptor, and return the SECCLASS appropriate to that file descriptor?",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2b051bfe_65f0fc21",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T03:10:52Z",
      "side": 1,
      "message": "Good catch! I believe that could be accessed by:\n\nstruct inode_security_struct *isec;\nstruct inode *inode \u003d file_inode(file);\nisec \u003d inode-\u003ei_security;\nisec-\u003esclass\n\nI will update tomorrow",
      "parentUuid": "eb106340_faa0297a",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_19f08fee",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "This is problematic; you are reusing an existing class/permission combination for a completely different purpose and different target context.  You really need a new permission for this check.  And it has to be added to COMMON_FILE_SOCK_PERMS in security/selinux/include/classmap.h so that it is defined for all file and socket classes.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ba19b5e_1ce5f562",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010099
      },
      "writtenOn": "2015-01-15T23:25:03Z",
      "side": 1,
      "message": "Actually, I think this check still won\u0027t be right even with its own permission.  IIUC, you want to be able to express in policy goals like \"untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device\".  Which requires that your check take into account the task/cred SID, the device node SID (i.e. the inode SID), and the ioctl command.  Normally we would think of the ioctl command as corresponding to a permission, but of course we can\u0027t support such a mapping due to the limited permission space and vast ioctl space.  By trying to map the ioctl command to a target SID, you are losing the device node SID from the equation.  Two independent checks, one on the device node SID and one on the ioctl command SID, doesn\u0027t seem sufficient, e.g. if you want to allow ioctl command N on device node D1 and ioctl command M on device node D2, you\u0027ll have to allow ioctl to D1 and D2 and ioctl (or new permission) to SID(N) and SID(M).  Which will also allow ioctl M on D1 and N on D2.  All that to say that I would not try to model this as a regular permission check.  Instead, just introduce a new structure within the policydb and a new function exported by the security server that allows checking based on source SID (the task/cred SID), target SID (the inode SID for the device file), maybe the target class (if we think we\u0027ll use the same target SID on both block and character devices and need to distinguish?), and the ioctl command.  Internally we\u0027d have something like the avtab to look up by source type, target type, and target class, and then check against your whitelist of ioctl commands.  More work, and more of a change to libsepol/checkpolicy, but seems more suited.",
      "parentUuid": "6b2473a4_19f08fee",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bcfdb48_cca10f36",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-01-16T00:20:20Z",
      "side": 1,
      "message": "\u003e IUC, you want to be able to express in policy goals like \"untrusted apps can only invoke ioctls A, B-D, and Q on the gpu device\".\n\nThat\u0027s the ideal state, but I\u0027d also be OK with being able to express a policy like:\n\n  untrusted_apps can only invoke ioctls A, B-D, and Q on a character device\n\nwhich isn\u0027t as good as what you proposed above...\n\nIf we\u0027re trying to express the ideal state, what would that look like from a policy perspective? More concretely, I\u0027m having a tough time envisioning what an \"allow\" rule would look like under such a scenario.\n\nLike this?\n\n  allow untrusted_app gpu_device:chr_file ioctlA;\n  allow untrusted_app gpu_device:chr_file ioctlBD;",
      "parentUuid": "2ba19b5e_1ce5f562",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}