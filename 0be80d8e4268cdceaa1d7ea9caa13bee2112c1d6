{
  "comments": [
    {
      "key": {
        "uuid": "6b2473a4_99e25f2d",
        "filename": "include/linux/lsm_audit.h",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Could make this a struct containing both the struct path (or dentry or whatever) and the unsigned int ioctlcmd and then display them both together on denials.  Also, this file diff belongs with the other change.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_dd6c3f75",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "I\u0027d put this file diff with the change that creates this header file. More generally, you only need at most two changes - one for the general LSM infrastructure and one for SELinux.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b49377c_8323fe11",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T21:44:59Z",
      "side": 1,
      "message": "Rgr. So two patches, a small (~20 lines) lsm_audit patch, and a much larger (~350 lines) selinux patch.",
      "parentUuid": "eb106340_dd6c3f75",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_39eb4b08",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3137,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use cred_sid() helper.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_9d76c73f",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3142,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "Use a struct so you can pass both the path and the cmd for inclusion in the audit message.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb106340_faa0297a",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-01-15T02:10:54Z",
      "side": 1,
      "message": "a file descriptor could represent a plain file, character file, unix domain socket, etc... All of these can have ioctls performed on them.\n\nIt feels wrong to use SECLASS_FILE here, since it could also be a SECCLASS_CHR_FILE or SECCLASS_TCP_SOCKET depending on how it\u0027s called.\n\nStephen: are there any functions available which take a file descriptor, and return the SECCLASS appropriate to that file descriptor?",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2b051bfe_65f0fc21",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3143,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2015-01-15T03:10:52Z",
      "side": 1,
      "message": "Good catch! I believe that could be accessed by:\n\nstruct inode_security_struct *isec;\nstruct inode *inode \u003d file_inode(file);\nisec \u003d inode-\u003ei_security;\nisec-\u003esclass\n\nI will update tomorrow",
      "parentUuid": "eb106340_faa0297a",
      "range": {
        "startLine": 3143,
        "startChar": 35,
        "endLine": 3143,
        "endChar": 48
      },
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b2473a4_19f08fee",
        "filename": "security/selinux/hooks.c",
        "patchSetId": 1
      },
      "lineNbr": 3144,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-01-15T15:16:12Z",
      "side": 1,
      "message": "This is problematic; you are reusing an existing class/permission combination for a completely different purpose and different target context.  You really need a new permission for this check.  And it has to be added to COMMON_FILE_SOCK_PERMS in security/selinux/include/classmap.h so that it is defined for all file and socket classes.",
      "revId": "0be80d8e4268cdceaa1d7ea9caa13bee2112c1d6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}