{
  "comments": [
    {
      "key": {
        "uuid": "2368f29d_882c1f40",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1070083
      },
      "writtenOn": "2015-04-10T18:20:16Z",
      "side": 1,
      "message": "Are all these changes same except commit text?\nhttps://android-review.googlesource.com/#/c/146291/\nhttps://android-review.googlesource.com/#/c/146292/\nhttps://android-review.googlesource.com/#/c/146310/",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907ac6a8_6c155173",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 424,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2015-04-16T15:36:58Z",
      "side": 1,
      "message": "I think the changes above here look fine -- they mean we are calculating the new_freq based on the current frequency instead of our un-attained target that might no longer be appropriate.\n\nThe changes below here don\u0027t seem right though since they are deciding whether we need to set target_freq to the new_freq and whether or not to rearm the timer.",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30d59acf_3a0b20ad",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 433,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2015-04-16T15:36:58Z",
      "side": 1,
      "message": "if new_freq \u003e cur but new_freq \u003c target, we leave target alone on this pass even though it is now stale. We don\u0027t want to skip to \"rearm\" since that skips setting the new target at line 487.",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10597645_43260ee6",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 433,
      "author": {
        "id": 1070083
      },
      "writtenOn": "2015-04-16T17:41:08Z",
      "side": 1,
      "message": "\"new_freq \u003e cur but new_freq \u003c target\" means target \u003e cur, which shouldn\u0027t really happen as long as we are always waking up speedchange task correctly and setting frequency properly, right?\n\nEven if it happens, I could argue that policy-\u003ecur should have been target_freq and not letting target_freq to drop is the right thing. The CPU never gets a chance to run at target_freq and apparently current frequency is still not enough.\n\nMore importantly though we probably want to wake up speedchange_task if target \u003e cur. On the other hand new_freq could be same as target_freq at any time. So if we really want to handle the error case where speedchange task could fail to change frequency, 55c5ba1 alone is not enough. We need to diligently check before every return whether we want to wake it up or not. Worse yet, if we cancel timer at fmax, we might never have such a chance to remedy the situation in timer function, and speedchange_task needs to check return value of __cpufreq_driver_target() and somehow recover. I think that\u0027s a separate (and not trivial) issue though.",
      "parentUuid": "30d59acf_3a0b20ad",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30d59acf_5a4144f7",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 475,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2015-04-16T15:36:58Z",
      "side": 1,
      "message": "This doesn\u0027t seem right either. This conditional is deciding whether our target_freq is staying the same and if so skips setting target_freq to the new value at line 487. If we\u0027ve calculated a new frequency, we want to set target_freq.",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10597645_23231ad5",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 475,
      "author": {
        "id": 1070083
      },
      "writtenOn": "2015-04-16T17:41:08Z",
      "side": 1,
      "message": "Agree. Missed this one. It needs to be target_freq.",
      "parentUuid": "30d59acf_5a4144f7",
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4365e6c2_5d164f00",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1070083
      },
      "writtenOn": "2015-04-10T18:20:16Z",
      "side": 1,
      "message": "I think this has to be target_freq or we could keep CPU at high freq indefinitely.\n\nImagining two CPUs managed by one policy. CPU A is fully busy and its target_freq is policy-\u003emax, and thus keeping cluster frequency at policy-\u003emax. CPU B is idling at non-min freq with both timer scheduled. (They could be scheduled before CPU A ramped up to policy-\u003emax.)\n\nCPU B wakes up at beginning of the window where slack_timer would fire. Its regulaor timer drops its target_freq to policy-\u003emin because load is 0. With this change, it won\u0027t schedule regular timer, but slack timer is left unchanged.  CPU B does quite a lot of work before going to sleep again in same window. CPU B\u0027s slack time fires at end of this window, sees the busy time CPU B consumed in that window, and ramps up its target_freq to some middle frequency. CPU B\u0027s timers are again not scheduled because CPU A is keeping policy-\u003ecur at policy-\u003emax. If CPU B goes to long idle afterwards, its target_freq will keep policy frequency high forever even if CPU A ramps down to policy-\u003emin later.",
      "range": {
        "startLine": 499,
        "startChar": 5,
        "endLine": 499,
        "endChar": 9
      },
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "907ac6a8_6c679123",
        "filename": "drivers/cpufreq/cpufreq_interactive.c",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2015-04-16T15:36:58Z",
      "side": 1,
      "message": "I agree with Junjie that line 499 should use target_freq -- remember, this is the newly calculated target_freq (line 487), and our check for rearm should be based on the expectations of where we think we are going to be during the interval",
      "parentUuid": "4365e6c2_5d164f00",
      "range": {
        "startLine": 499,
        "startChar": 5,
        "endLine": 499,
        "endChar": 9
      },
      "revId": "89db6b68e9f82aa52077f6bf7d819dab74265790",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}