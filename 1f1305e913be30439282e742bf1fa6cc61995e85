{
  "comments": [
    {
      "key": {
        "uuid": "AAAA/3///oA\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 334,
      "author": {
        "id": 1006275
      },
      "writtenOn": "2011-04-28T08:18:16Z",
      "side": 1,
      "message": "If this function covers IOMMU mappings, this doesn\u0027t need to be pointer type but an integral type because CPU is unable to access the device address mapped for IOMMU",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAABAn///Qo\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 498,
      "author": {
        "id": 1006275
      },
      "writtenOn": "2011-05-19T06:51:03Z",
      "side": 1,
      "message": "What if there are more than one request to create an ion_client in the same task\u0027s address space? It is likely to be happened in the kernel mode.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///oE\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 516,
      "author": {
        "id": 1006275
      },
      "writtenOn": "2011-04-28T08:18:16Z",
      "side": 1,
      "message": "I think this is wrong.\nbecause the initial node, \u0027*p\u0027 is not the node in kernel_clients.\nThus the new ion_client is linked in user_clients but reordering is done in kernel_clients.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n//+n4\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 654,
      "author": {
        "id": 1006181
      },
      "writtenOn": "2011-04-13T15:44:30Z",
      "side": 1,
      "message": "as mentioned y\u0027day (just capture here for posterity), it would be nice if you let the heap implementation optionally provide a fault handler.. could be useful to track cache cleanness, and also probably other usages in cases where you have a GART/GTT or something that vaguely looks like one..",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///oQ\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 774,
      "author": {
        "id": 1006275
      },
      "writtenOn": "2011-04-28T08:18:16Z",
      "side": 1,
      "message": "Did you intended to let users know kernel virtual address as a handle?\nDoesn\u0027t it have a security problem?",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///oI\u003d",
        "filename": "drivers/gpu/ion/ion.c",
        "patchSetId": 5
      },
      "lineNbr": 988,
      "author": {
        "id": 1006275
      },
      "writtenOn": "2011-04-28T08:18:16Z",
      "side": 1,
      "message": "I think you assumed that we need just one mapper for user\u0027s address space. I think we need more than one mapper for users.\nUsers may want non-cacheable mapping rather than cacheable mapping.\nOtherwise, passing flags seems enough.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///vY\u003d",
        "filename": "drivers/gpu/ion/ion_priv.h",
        "patchSetId": 5
      },
      "lineNbr": 97,
      "author": {
        "id": 1006279
      },
      "writtenOn": "2011-04-27T15:00:17Z",
      "side": 1,
      "message": "Do you mean kernel-space virtual address?",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///vU\u003d",
        "filename": "include/linux/ion.h",
        "patchSetId": 5
      },
      "lineNbr": 114,
      "author": {
        "id": 1006279
      },
      "writtenOn": "2011-04-27T15:00:17Z",
      "side": 1,
      "message": "Same question as below for ion_allocation_data.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///vg\u003d",
        "filename": "include/linux/ion.h",
        "patchSetId": 5
      },
      "lineNbr": 132,
      "author": {
        "id": 1006279
      },
      "writtenOn": "2011-04-27T15:00:17Z",
      "side": 1,
      "message": "Do you mean kernel-space virtual address?  If you really mean physical, return address should be an unsigned integer.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///vs\u003d",
        "filename": "include/linux/ion.h",
        "patchSetId": 5
      },
      "lineNbr": 203,
      "author": {
        "id": 1006279
      },
      "writtenOn": "2011-04-27T15:00:17Z",
      "side": 1,
      "message": "This is fine for a linear (1D) allocation.  Will the same API be used for other (e.g. 2D) allocation for architectures that have 2-dimensional memory layout?  If yes, how will the other dimensions be specified?",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/3///vQ\u003d",
        "filename": "include/linux/ion.h",
        "patchSetId": 5
      },
      "lineNbr": 204,
      "author": {
        "id": 1006279
      },
      "writtenOn": "2011-04-27T15:00:17Z",
      "side": 1,
      "message": "If you need to allocate multiple co-aligned buffers, will this be expected to be done in one alloc call?  E.g. on some 2D architectures NV12/NV21/etc buffers need to be coaligned if they are mapped contiguously (as 1 buffer) to user space.  Other option is to require user space to always handle each sub-buffer individually.",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAA/n//+nk\u003d",
        "filename": "include/linux/ion.h",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1006181
      },
      "writtenOn": "2011-04-13T15:44:30Z",
      "side": 1,
      "message": "fwiw GEM does not try to standardize the allocation ioctl/api..  I think if you do you end up having to rev the API each time a new SoC comes along with something new and crazier.  Instead memory allocation is done by a vendor provided userspace driver (either their xorg driver, or hw specific vaapi/vdpau driver).  So when a buffer object (bo) is allocated for multimedia, maybe some of the options passed down to vendor specific kernel part would be different compared to bo\u0027s allocated for graphics pixmaps..  and might differ from gpu to gpu.\n\nInstead the approach is to standardize the API for passing around / manipulating buffers once they are allocated.\n\nI\u0027m not sure if that sort of approach fits in with the Android userspace architecture.. but I guess there is vendor specific OMX implementation, gralloc, etc.  So I guess it might?",
      "revId": "1f1305e913be30439282e742bf1fa6cc61995e85",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}